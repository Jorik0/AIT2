\documentclass[a4paper,11pt]{article}


\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{tabto}

\usepackage[english]{babel} %English hyphenation
\usepackage[utf8]{inputenc}

%Hyperreferences in the document. (e.g. \ref is clickable)
\usepackage{hyperref}
\usepackage{float}
\usepackage{array}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{anysize,fancyhdr,epsfig}
\lstset{tabsize=2}
\setlength\parindent{0pt}

\title{Artificial Intelligence Techniques Assignment 2}
\author{Jorik Oostenbrink (4169263) and Bernt Foppes (9243144)}
\date{}


\begin{document}
\maketitle	

\section{Introduction}
This is the report for the GOAL Multi-Agent Elevator assignment. In this assignment we were asked to develop a multi-agent system in which a manager agent allocates tasks among elevators (each controlled by a single agent) using an auction mechanism.
\newline\newline
The main goal of the MAS should be to "bring everyone as quickly as possible to his or her target floor". This is measured in the form of average total time (i.e. average waiting time + average travel time).
\newline\newline
This report is ordered in the same way as the assignment. That is, in part A we will answer some questions posed in relation to the original (unextended) multi-agent system. In part B we describe our extension's design, implementation and performance. Here we will also give our conclusions about the performance of the agent and the use of logic in implementing this kind of system. Finally, in assignment part C feedback is given on using GOAL.
\newline\newline
The GOAL Multi-Agent Elevator Manager assignment has as main objective to improve the performance of an elevator manager by means of implementing a multi-agent system (MAS). This MAS implements a manager agent which assigns tasks to the individual elevators based on a bidding system. The elevator with the best bid will get the task assigned to him. Assigning of the tasks should be intelligent by taking into account a number of factors which determine the value of the bid calculated. 
\newline\newline
We completed the assignment by extending the MAS included with GOAL (elevator.mas2g) in the Goal Eclipse plugin version 1.3.3.201511161655.

\section{Assignment part A}

\subsection{Question 1}
\textit{Explain why all elevators move to floor 9, and explain why they do not stop to pick up other people along the way.}
\newline\newline
All elevators move to floor 9 first, as that is the first floor a person presses the floor button on. Pressing the button generates a fButtonOn percept, which in turn leads (after adding the info to the believe state) to the agents adding a goal to go this floor (with the correct direction). The agents then decide to fulfil this goal by going to floor 9, as they don't have any other goals yet. The agents don't tell each other where they going, so they all go to the same floor instead of adapting their plans to each other.
\newline\newline
The reason the elevators do not stop to pick up other people along the way is that the agents only change their goals when they are docked (in this case when they reach floor 9), as atFloor (used in onRoute, which in turn is used when changing goals because of fButtonOn) is only true when directly at a floor.

\subsection{Question 2}

\textit{Explain why the elevator that brings the person from the 9th to the 1st floor indicates that it will go down when it reaches the ground floor (which is not possible anyway), i.e. explain why the agent performs the action goto(1,down).}
\newline\newline
The reason the elevator that brings the person from the 9th to the 1st floor indicates that it will go down when it reaches the ground floor is that it performed the action goto(1,down), as the elevator was going to go in the down direction when it was at the floor where the person got on and for that reason added the atFloor(1),dir(down) goal (forall bel(percept(eButtonOn(Level)), dir(Dir)) do adopt(atFloor(Level), dir(Dir)).). In other words, as the direction was down it will still indicate to go down even though this doesn't exists for this level.

\section{Assignment part B}

\subsection{MAS design}
In our MAS design we've created a manager agent. All fButton(Level,Dir) percept events in the elevator agent are send to this manager agent. The manager agent processes these events, creates new tasks and sends requests for bids on jobs to the elevator agents. The elevator agents calculate their bid and send this back to the manager. For all bids received, the manager determines the best bid, which is simply the bid with the highest value. The agent which gave the best bid gets assigned the task. As the elevator agents are also programmed by us (and they don't actually have to `pay' anything), so the auction does not need to account for lying agents which is why we can just choose the highest bid. The manager only processes one task at a time, as the assignment of a previous task influences the bids on other tasks. So the manager can't ask for bids on multiple tasks at a time. 
\newline\newline
All elevator agents need to calculate their bid taking into account a number of variables. A very important one is the capacity of a car in relation to the number of people currently in a car, as it not possible to accept new tasks when the car is full (although it would be if people are dropped first before letting new ones in). To be efficient in terms of traveling distance and thus time, it is relevant to know the distance from the current position to the position of the floor belonging to the task to be performed. We also introduced a variable which determines the number of jobs an elevator currently has. This indicator is deemed the second most important variable because an even spreading of tasks will lead to an overall more efficient handling of requests. A car that has no jobs at all (jobLess) gets a 'bonus' mark i.e. will generate a higher bid value than other cars. The final variable used in calculating bids is onRoute meaning the car is traveling in the direction of the floor belonging to the task to be performed. 

The above described MAS design can be captured into a single main formula for generating a bid value:
\newline
\[bid = -a\frac{CY}{CY-people+\epsilon} - b|dest - carPos| + c*jobLess - d*numJobs + e*onRoute\]
\newline\newline
Where
\begin{enumerate}
	\NumTabs{5}
	\item[] $CY$
	\tab{capacity of the car} 
	\item[] $people$
	\tab{number of passengers currently in the car}
	\item[] $dest$ 
	\tab{destination floor of the task to be performed}
	\item[] $carPos$  
	\tab{current position of the car}
	\item[] $jobLess$ 
	\tab{defined as $1$ when $numJobs$ = $0$ and $0$ otherwise}
	\item[] $numJobs$
	\tab{number of assigned uncompleted tasks}
	\item[] $onRoute$ 
	\tab{defined as $1$ when destination floor of the task to be performed is}
	\tab{in the same direction as the current traveling direction and $0$ otherwise}	
\end{enumerate}

Within the formula all variables are weighted to define their importance within the overall resulting bid value. The fact that the variables produce values on different scales is taken into account, we've chosen not to normalize these values. The factor $\epsilon$ is used to avoid possible division by zero. The weighing factors $a$, $b$ and $d$ have a negative contribution i.e. result in a lower bid value while $c$ and $e$ have a positive contribution. The goal of generating a bid value is to produce the highest value bid for the car best to handle/get the task from the manager agent, the manager agent will assign the task to the car with the highest bid value. The weighing factors used are:
\[\begin{array}{lcl}
a & = & 1\\
b & = & 1\\
c & = & 5\\
d & = & 1\\
e & = & 10\\
\epsilon & = & 0.0001
\end{array}\]

\subsection{Implementation}
\subsubsection{Elevator}
The elevator agent has the following main decision rules:

\paragraph*{Sending a bid}
\begin{verbatim}
if a-goal(answered(ID)), bel(task(Destination,DestinationDir,ID)),
constants(A,B,C,D,E,Eps),
numJobs(NumJobs),		
bel(((numJobs = 0) -> Jobless = 1 ; Jobless = 0)),
onRouteMacro(OnRoute,Destination,DestinationDir),
bel(capacity(Capacity), people(People), carPosition(Pos)),
bel(Bid is 
A*(Capacity/(Capacity-People+Eps)) 
- B*abs(Destination-Pos)
+ C*Jobless
- D*NumJobs
+ E*OnRoute)  then
(manager).send(bid(ID,Bid)).
\end{verbatim}

In this rule we first check if we have a (not yet achieved) goal of answering a request for a bid. The rest is just used for calculating the bid itself (using some macros for example to get the constants) and sending it to the manager. This rule shows that calculating bids using logic based programming is a bit more difficult than it needs to be.

\paragraph*{Moving to a different floor}
\begin{verbatim}
if a-goal( atFloor(Level), dir(Dir) ),
bel(goingTo(Current), carPosition(Here), 
Distance is abs(Level-Here), direction(Here,Level,Direction) , 
CurrentDistance is abs(Current-Here), Distance < CurrentDistance),
closest(Distance,Here,Dir,Direction) then 
goto(Level, Dir) + delete(goingTo(Current)) + insert(goingTo(Level)).

if a-goal( atFloor(Level), dir(Dir) ),
bel(not(goingTo(Current)), carPosition(Here), 
Distance is abs(Level-Here), direction(Here,Level,Direction)),
closest(Distance,Here,Dir,Direction) then
goto(Level, Dir) + insert(goingTo(Level)).
\end{verbatim}

The first rule triggers when the elevator is already moving to a floor, in this case it only changes its destination if it's actually closer. Both rules use the following macro to find the floor which is actually the most preferable to go to:

\begin{verbatim}
#define closest(Distance,Here,Dir,Direction)
bel(dir(CurrentDir)), 
not(a-goal(atFloor(OFloor), dir(CurrentDir), 
direction(Here, OFloor, CurrentDir), ODistance is abs(OFloor-Here),
(not((CurrentDir = Direction, CurrentDir = Dir)) ; ODistance < Distance))),
not(a-goal(not((CurrentDir = Direction, CurrentDir = Dir)), 
atFloor(OtherFloor), OtherDistance is abs(OtherFloor-Here), OtherDistance < Distance)).
\end{verbatim}

The first part of this macro is used to check if a floor exists (the elevator wants to go to) which is in the current direction the elevator is traveling (and has the same goal dir). In this case the rule fails if Dir is not this direction, if Level is not in this direction (aka if Directions is not Dir) or if Distance if larger than the distance to this floor. The second part only triggers when Level is not in the current direction and tests if there does not exist a floor (the elevator wants to go to) which is closer than Distance (regardless of direction).

These rules, just as the previous rule, show the disadvantage of logic based programming for some tasks. This macro is very complicated, and while it may be possible to improve it somewhat, implementing this kind of rule will always be more complicated in a logic based language than it is to implement a similar `rule' in other types of languages (such as java).

\subsubsection{Manager}
The manager has the following main decision rules.

\subsection{Performance}
In measuring the performance we have used the following parameter values:

\[\begin{array}{lcl}
Simulation & = & Random Rider Insertion\\
Floors & = & 10\\
Cars & = & 3\\
RandomSeed & = & 6353\\
Capacity & = & 8\\
People & = & 20\\
InsertionTime & = & 50000\\
TimeFactor & = & 3
\end{array}\] 

\pagebreak

The performance indicator used is the average total time ($avgtt$). The initial performance of the unadapted (besides the RandomSeed change to 6353) MAS distributed with Goal was:

\[\begin{array}{lcl}
avgtt & = & 132446.2
\end{array}\]

Our first improvement has been to remove a task when another car has already completed this. The manager agent keeps track of tasks, the car with highest bid gets the task assigned and when completed the manager removes this task from the tasklist which resulted in a performance of:
\[\begin{array}{lcl}
avgtt & = & 103479.35
\end{array}\]

We tried to improve the performance by adding a bonus to the bid value when a person currently in the car of an elevator already wants to go the destination level of the task for which a bid is requested. This resulted in a slightly worse performance:
\[\begin{array}{lcl}
avgtt & = & 105199.15
\end{array}\]

Originally the direction of a car is only updated when a car is docked i.e. not moving. As cars receive bid requests all the time it makes sense to also update this while a car is moving. The idea is to let a car better anticipate on bid requests and therefore generate higher bid values if relevant. This resulted in a performance improvement: 
\[\begin{array}{lcl}
avgtt & = & 102400.0
\end{array}\]

The final improvement we have made was by better utilize the direction of travel with respect to the destination floor belonging to a task for which the manager agent requests a bid. It is more efficient to get a task assigned when the destination floor of this task is one we already have to go to and/or is in the same direction as we are traveling. Implementing this resulted in a substantial performance improvement:
\[\begin{array}{lcl}
avgtt & = & 88380.5
\end{array}\]

The process of improving the overall performance consisted for the largest part of improving the efficiency of the individual cars by using a manager agent for coordination of tasks and improving the bid value calculation by deducing the best strategy. A smaller part consisted of trial and error in calculating this bid value by changing the weighing factors. We have tried to further improve the performance by changing these weighing factors but this didn't lead to a better performance. The initial values which were determined as an educated guess proved to be the best values in the end. However, due to the fact there are numerous possible combinations of different weighing factors we don't exclude the possibility the performance can be improved even further but this would take a very considerable amount of time to test. 

\subsection{Conclusions}
Overall we feel that for an assignment as the one described in this report, using logic is very useful. Abstractions from the assignment goals and formulating them into logic is believed to greatly reduce the amount of code required to implement a solution. On the other hand we felt we sometimes had to come up with workarounds as the deemed straightforward manner of coding could not be utilized. One example is using an if-statement within another if-statement. Another is implementing the bid calculation formula, we had to use beliefs while we required a simple calculation. 

\section{Assignment part C}
In terms of feedback on using the GOAL system we have more than two feedback comments but we will limit ourselves to the two most important ones. 

\subsection{Logging}
We noticed that the items that appear in the logging window are not ordered by the time on which they occurred. For example the log message that a goal is achieved appears before the log message of the action that resulted in the goal to be achieved. This can make it hard to understand/debug using logging. Also when an exception occurs it is sometime not clear from the logging what the root cause is of this exception.

\subsection{Debugging}
We very much wanted to use debugging using breakpoints but could not get this to work properly. The main reason is that we could change the code stepping options as this just shows a grey box instead of options to change (in Preferences \textrightarrow GOAL \textrightarrow Runtime \textrightarrow Code stepping). We encountered this issue on different operating systems. 

\end{document}

